<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ThreeDee</title>
</head>
<body>
<canvas id="glCanvas" width="640" height="480"></canvas>

<script>
    main();

    // attribute vec3 vertColor;
    // fragColor = vertColor;
    function main() {
        const vsSource = `
    attribute vec3 vertPosition;
    attribute vec3 vertColor;

    varying vec3 fragColor;

    void main() {
      fragColor = vertColor;
      gl_Position = vec4(vertPosition, 1.0);
    }
  `;
        const fsSource = `
    precision mediump float;
    varying vec3 fragColor;
    void main() {
      gl_FragColor = vec4(fragColor, 1.0);
    }
  `;
        const canvas = document.querySelector("#glCanvas");
        // Initialisierung des GL Kontexts
        const gl = canvas.getContext("webgl");

        // Nur fortfahren, wenn WebGL verfügbar ist und funktioniert
        if (!gl) {
            alert("Unable to initialize WebGL. Your browser or machine may not support it.");
            return;
        }

        // Setze clear color auf schwarz, vollständig sichtbar
        gl.clearColor(0.3, 0.7, 0.9, 1.0);
        // Lösche den color buffer mit definierter clear color
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Create and Compile shaders
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

        gl.shaderSource(vertexShader, vsSource);
        gl.shaderSource(fragmentShader, fsSource);

        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error('ERROR Compiling vertexShader', gl.getShaderInfoLog(vertexShader));
            return;
        }
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error('ERROR Compiling fragmentShader', gl.getShaderInfoLog(fragmentShader));
            return;

        }

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        gl.linkProgram(program)
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('ERROR Linking program', gl.getProgramInfoLog(program));
            return;
        }

        // Create Buffer
        let triangleVertexes =
            [// X.x, Y.y, Z.z, R.r, G.g, B.b
                0.0, 0.5, 1.0, 1.0, 0.0, 0.0,
                -0.5, -0.5, 0.0, 0.0, 1.0, 0.0,
                0.5, -0.5, 0.0, 0.0, 0.0, 1.0
            ]

        let triangleVertexBufferObject = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexBufferObject);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertexes), gl.STATIC_DRAW);

        // get attribute handle
        let positionAttributeLocation = gl.getAttribLocation(program, 'vertPosition');
        let colorAttributeLocation = gl.getAttribLocation(program, 'vertColor');

        // Specify attribute Layout
        gl.vertexAttribPointer(
            positionAttributeLocation, // Attribute Location
            3, // Number of elements each attribute has (X,Y,Z)
            gl.FLOAT, // Type of elements
            gl.FALSE, // Is
            6 * Float32Array.BYTES_PER_ELEMENT, // Sitze of a vertex
            0// Offset of the beginning of vertex
        )

        gl.vertexAttribPointer(
            colorAttributeLocation, // Attribute Location
            3, // Number of elements each attribute has (R,G,B)
            gl.FLOAT, // Type of elements
            gl.FALSE, // Is
            6 * Float32Array.BYTES_PER_ELEMENT, // Sitze of a vertex
            3 * Float32Array.BYTES_PER_ELEMENT// Offset of the beginning of vertex
        )

        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.enableVertexAttribArray(colorAttributeLocation);

        // Main Render Loop

        gl.useProgram(program);
        gl.drawArrays(gl.TRIANGLES, 0, 3);
    }

</script>
</body>
</html>